<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs on Bowser</title><link>https://bowser1704.github.io/categories/cs/</link><description>Recent content in cs on Bowser</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 17 Nov 2019 11:23:47 +0800</lastBuildDate><atom:link href="https://bowser1704.github.io/categories/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>return与exit的不同</title><link>https://bowser1704.github.io/note/2019/11/17/return%E4%B8%8Eexit%E7%9A%84%E4%B8%8D%E5%90%8C/</link><pubDate>Sun, 17 Nov 2019 11:23:47 +0800</pubDate><guid>https://bowser1704.github.io/note/2019/11/17/return%E4%B8%8Eexit%E7%9A%84%E4%B8%8D%E5%90%8C/</guid><description>
&lt;h2 id=&#34;首先问题就是有时候我们返回用return-有时候是exit是什么区别呢&#34;&gt;首先问题就是有时候我们返回用return，有时候是exit是什么区别呢？&lt;/h2&gt;
&lt;h3 id=&#34;首先明确函数执行&#34;&gt;首先明确函数执行&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;我们直接运行某些脚本，或者是`&lt;code&gt;sh x.sh&lt;/code&gt;，这背后是先fork一个shell再执行x.sh。&lt;/li&gt;
&lt;li&gt;source，就是直接在当前进程下执行一些文件，一般都是参数文件，不fork创建子进程。&lt;/li&gt;
&lt;li&gt;exec， 这是一堆程序集合，The exec() family of functions replaces the current process image with a new process image. 意思就是我们使用==一个新的进程==来代替==原来的进程==，也就是看上去很美，是一个进程。&lt;/li&gt;
&lt;li&gt;system， The system() library function uses fork(2) to create a child process that executes the shell command specified in command using execl(3) as follows:，就是说system = fork + exec + waitpid，就是可以这样来执行一个你想execute的程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;有两种fork-fork-与-vfork&#34;&gt;有两种fork fork 与 vfork&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fork 创建子进程， 复制数据到子进程&lt;/li&gt;
&lt;li&gt;vfork创建子进程， 父子共享内存，也就是为了exec，不用copy，因为其实他不需要很多父进程的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以如果是vfork，你直接return的话，父子进程公用堆栈，那你就干掉了父进程，但是exit是从子进程退出。&lt;/p&gt;</description></item><item><title>csapp Chapter11 网络编程</title><link>https://bowser1704.github.io/note/2019/11/13/csapp-chapter11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 13 Nov 2019 21:30:14 +0800</pubDate><guid>https://bowser1704.github.io/note/2019/11/13/csapp-chapter11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>
&lt;p&gt;主要记录一下socket相关内容，网络协议不多做描述。&lt;/p&gt;
&lt;p&gt;下图是基本的步骤图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.superbed.cn/item/5dcd2bb58e0e2e3ee9164936.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;getaddrinfo&#34;&gt;getaddrinfo&lt;/h2&gt;
&lt;p&gt;一句话：获取套接字地址，从url，也就是dns获取真正的ip地址，返回的结构中是一个链表，有多个sockaddr(也就是dns会给我们返回多个ip地址)，我们通过遍历来确定哪一个可用，如果都没有用，就error了。&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sockaddr是socket地址结构，16个字节，前两个字节标明协议簇，后面的字节其实可以变动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为IPV4与IPV6一个32位(4个字节)，一个128位(16个字节)，所以sockaddr装不下IPV6，就有sockaddr_in 16个字节，sockaddr_in6 28个字节。但是其实都是可以转化为sockaddr使用，也就是我们使用的就是sockaddr，为什么呢，因为我们每次传参传的是sockaddr指针，并且还有一个sockaddr_len，既然有了长度，结构体底层不一样也没事了，需要的是指针+长度，就可以得到完整数据。&lt;/p&gt;
&lt;p&gt;整理一下有几种sockaddr结构&lt;/p&gt;
&lt;p&gt;sockaddr 16 bytes
sockaddr_in 16 bytes for IPv4
sockaddr_in6 28 bytes for IPv6
sockaddr_storage 128 bytes for all protocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;返回的是addrinfo链表，里面除了sockaddr指针外，还存放了，数据协议，一些可选参数，balabala的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用它是直接返回addrinfo，我们在socket等函数中可以直接使用这些属性作为参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S.：csapp中有些函数讲的是全小写，使用时首字母却大写了，例如getaddrinfo，使用时却是Getaddrinfo，其实是做了一个封装。例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Getaddrinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrinfo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addrinfo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//加了一个错误处理，其他都差不多
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getaddrinfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;gai_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Getaddrinfo error&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;client创建&#34;&gt;client创建&lt;/h2&gt;
&lt;p&gt;getaddrinfo -&amp;gt; socket -&amp;gt; connect ** open_clientfd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getaddrinfo 不多做解释&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket 得到一个clientfd，这个时候还没有网络什么事，仅仅是自己创建一个socket fd，内核会动态分配一个port。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;connect 这个时候开始有网络了，connect里面要填server的sockaddr，记住还有addrlen，这是sockaddr可以适用于不同协议的关键。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;open_clientfd是用来替换上面几个步骤的。&lt;/p&gt;
&lt;h2 id=&#34;server创建&#34;&gt;server创建&lt;/h2&gt;
&lt;p&gt;getaddrinfo -&amp;gt; socket -&amp;gt; bind -&amp;gt; listen -&amp;gt; accept&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;socket+bind+listen 用来创建一个listenfd，** open_listenfd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket 创建一个socket fd，暂时没什么用，参数有协议和一些可选参数。&lt;/li&gt;
&lt;li&gt;bind 这个时候bind地址，也就是传入sockaddr和sockaddr_len，确定这个socket绑定什么socket地址，与client不同，前者是动态分配的。&lt;/li&gt;
&lt;li&gt;listen 确认这个socket fd 是 listenfd 区分于 connfd(connecting fd)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;open_listenfd就是把上面四个步骤整合了，但是还是要手写accept。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;accept 创建一个connfd，这是真正与client通信的socket，listenfd是用来监听的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意一个问题，我们在getaddrinfo的时候hints.ai_flags设置了参数AI_PASSIVE，这是说我们host参数设置为0，也就是发送到本主机的所有ip地址我们都会接受。host值是通配符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是说你舍友和你在同一个局域网内，是可以访问到你的。如果你设置了，也就是指定了ip，只有这个满足的ip才可以访问你，可以使用通配符。&lt;/p&gt;
&lt;p&gt;这样的话你就可以使用局域网利用http协议和你室友传输文件了。&lt;/p&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;p&gt;http请求注意格式，头部，实际内容。其实我们往socket里面写的就是字符串，但是是按照http的格式来写的，开头怎么样，头部怎么样，都是约定好的。所以我们解析http请求（注意uri是http请求内的一部分字段），做出不同的响应&lt;/p&gt;
&lt;h3 id=&#34;静态内容响应&#34;&gt;静态内容响应&lt;/h3&gt;
&lt;p&gt;根据uri中的文件位置，我们返回文件。（如果是直接/，我们手动定位到home.html文件。），那么文件怎么返回/发送呢&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span class=&#34;cm&#34;&gt;/* Send response body to client */&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//打开文件，readonly
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcfd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_RDONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//原做法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//虚拟内存内容相关，将文件/利用文件描述符 映射到一块虚拟空间，srcp。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PROT_READ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAP_PRIVATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;srcfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//关闭文件描述符号，已经有了虚拟内存空间上面的映射，不需要再read-&amp;gt;write，防止内存泄露
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//写入coonfd，send response body to client
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Rio_writen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//释放虚拟内存中的空间，防止内存泄露
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Munmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//作业11-9 做法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Rio_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Rio_readinitb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;srcfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Rio_readnb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//上面三步步骤可以用Rio_readn(srcfd, srcp, filesize)无缓冲函数; 直接代替.题目要求这种。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Rio_writen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;srcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以其实还是打开文件，写入另一个文件描述符，就是发送了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一个问题：为什么不直接用srcfd，先读取srcfd，到buf，在写入coonfd中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作业11-9就让你修改这种方式，直接用malloc和rio_readn，rio_writen写入fd&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还记得我们上面说可以和室友传输文件吗？但是我们首先要实现支持MPG等视频文件的web&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作业11-7就是让我们手写支持MPG视频文件。&lt;/p&gt;
&lt;p&gt;我们可以get_filetype加入一个mp4-&amp;gt;viedo/mpge4，但是返回的直接是文件，还没有名字。&lt;/p&gt;
&lt;h3 id=&#34;动态内容响应-cgi&#34;&gt;动态内容响应 cgi&lt;/h3&gt;
&lt;p&gt;parse_uri中会将uri中的参数，也就是调用的cgi程序的位置表明出来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Dynamic content */&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//返回 &amp;#39;?&amp;#39;在uri中出现的index
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgiargs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//把？后面的参数copy给cgiargs
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//不存在?的情况
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cgiargs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//下面是把filename变成了.uri(./cgi-bin/adder)，也就是linux下的相对文件名字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;strcat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;dynamic filename=%s uri=%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我们在cgi中调用如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Child */&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//line:netp:servedynamic:fork
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Real server would set all CGI vars here */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;setenv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;QUERY_STRING&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cgiargs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Dup2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;STDOUT_FILENO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Redirect stdout to client */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Execve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;emptylist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Run CGI program */&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//等待子进程die，完成后函数才结束
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* Parent waits for and reaps child */&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;有一个问题，上面是直接wait，等待子进程死亡，在结束这个函数，联想一下，异常控制流那一章节，直接处理SIGCHLD信号，回收子进程的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是作业11-8，怎么操作呢？未定，怎么解决呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ch_signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//子进程中都还没有终止，就立即返回0.否则返回终止子进程号，这样的话，在等待子进程的时候，我们还是可以做自己的事情的。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;waitpid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WHOHANG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//main函数中，加一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGCHILD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch_signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;注意几点&#34;&gt;注意几点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编译代码时，要加上-lpthread，gcc不再使用老的线程库pthread。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CGI是标准&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;http请求如何响应，我们都知道传输的是二进制序列（模拟信号-&amp;gt;数字信号），拿过来之后也只能解析成字符串，那怎么分辩什么是什么呢？&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有两种方法，一种是就是每句话后面接上一个&lt;code&gt;\r\n&lt;/code&gt;，标识这句话已经说完了，第二种是开头加上一个长度，标识后面这句话的长度是多少。http请求的头部是采用&lt;code&gt;\r\n&lt;/code&gt;，而data是采用length的方法，所以你会看到http请求header里面会有一个Content-length字段。&lt;/p&gt;
&lt;p&gt;注意最后一个header会有两个“\r\n\r\n”，这是为了区分content和header。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将congtent-length设置为int，所以传输大文件会出问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以去看我在tiny文件上做的笔记。&lt;a href=&#34;https://github.com/Bowser1704/csapp/blob/master/chapter11/tiny.c&#34;&gt;tiny.c&lt;/a&gt;&lt;/p&gt;</description></item><item><title>csapp Chapter10 UnixIO</title><link>https://bowser1704.github.io/note/2019/11/12/csapp-chapter10-unixio/</link><pubDate>Tue, 12 Nov 2019 22:05:45 +0800</pubDate><guid>https://bowser1704.github.io/note/2019/11/12/csapp-chapter10-unixio/</guid><description>
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;首先要有一个思维，Linux上面基本上所有外部设备都是文件，都是通过IO来读取，写入的，包括键盘，网络，终端&amp;hellip;..&lt;/p&gt;
&lt;p&gt;P.S.：为什么终端是呢，想象一下以前大型计算机，只有一台主机，不同人使用，就是有多个终端(物理设备)来操作系统，只不过现在我们用的微机就是一台主机了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.superbed.cn/item/5dcabfbd8e0e2e3ee9b257f5.jpg&#34; alt=&#34;上一张图&#34; /&gt;&lt;/p&gt;
&lt;p&gt;看这张图片，可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外设都是走I/O总线，从而与系统交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;那怎么使用文件呢&#34;&gt;那怎么使用文件呢&lt;/h3&gt;
&lt;p&gt;一句话：系统打开文件时会生成两个结构一个是在系统表上，一个是在v-node表上。前者存储的是某个进程对文件读取的偏移量，后者储存的是文件的固有属性，文件大小，文件权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件读取的偏移量：你打开一个文件会进行读取，不可能一次读完，也不可能每次读都从头开始，而是记录你上次读到哪里了，这就是偏移量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于某个进程来说：一个进程会打开多个文件，怎么管理呢？有一张表，叫做描述符表，每个打开的文件都有一个ID，也叫作描述符，你打开文件后，描述符就代表你的文件了。看下面的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.superbed.cn/item/5dcac3bc8e0e2e3ee9b6fc15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子进程继承父进程的文件，有自己的描述符，但是指向相同的文件表。&lt;/li&gt;
&lt;li&gt;一个进程打开两次同一个文件，会有两个描述符，但是同一个文件表结构。&lt;/li&gt;
&lt;li&gt;文件表结构只有refcnt=0才会关闭，也就是引用他的文件描述符为0，才会关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P.S.：每个进程会默认打开三个文件，有三个描述符 0=标准输入(Stdin)，1=标准输出(Stdout)，2=标准错误(Stderr)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;整数值&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;名称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;unistd.h符号常量[&lt;a href=&#34;https://zh.wikipedia.org/wiki/文件描述符#cite_note-1&#34;&gt;1]&lt;/a&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;stdio.h文件流[&lt;a href=&#34;https://zh.wikipedia.org/wiki/文件描述符#cite_note-2&#34;&gt;2]&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Stdin&#34;&gt;Standard input&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;STDIN_FILENO&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;stdin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Stdout&#34;&gt;Standard output&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;STDOUT_FILENO&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;stdout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Stderr&#34;&gt;Standard error&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;STDERR_FILENO&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;stderr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;unix-io&#34;&gt;Unix IO&lt;/h2&gt;
&lt;p&gt;打开文件用到了open函数返回的是文件描述符，注意两个参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//flags是进程如何访问这个文件，只读还是只写，或者不存在时新建
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//mode是创建文件时指定权限，就是正常的文件权限，读写执行，这里有一个umask，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//每个进程都有一个umask，通过umask函数执行，真正的mode为 mode &amp;amp; ~umask
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//出错返回-1 否则返回文件描述符
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ssize_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读和写文件，Unix IO读写文件都是无缓冲的，也就是说每次读文件，都要陷入内核态，按照指定的字节大小读取放到给定的字符指针内，如果遇到EOF就返回0，否则返回读取字节大小，出错返回-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssize_t与size_t，前者是signed，因为可能返回-1，后者是unsigned，读取字节数&amp;gt;=0。&lt;/li&gt;
&lt;li&gt;EOF，指的是当当前文件位置指向文件的最后，也就是文件偏移量等于文件长度时候，引发的end-of-file。并不实际存在这个东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rio与标准库io&#34;&gt;RIO与标准库IO&lt;/h2&gt;
&lt;p&gt;这些函数有些事要是有缓冲区的，怎么实现的呢，就是新建一个缓冲结构，每次调用Unix IO时尽可能的读取足够多的字节(等于缓冲区大小)，陷入内核态费时间，这样的话，如果下次再读，直接去缓冲区拿(空间换时间)。&lt;/p&gt;
&lt;p&gt;标准库io也是格式化输入输出，并且也有缓冲区，但是也有很多问题，不适合在网络编程上使用，&lt;/p&gt;
&lt;p&gt;这里就是一些函数，去看书，看具体实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要理解我们read文件的时候有才需要有缓冲，write文件的时候缓冲意义就不大了。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;rio read函数分为两批，参数不同，rio_t作为参数要先rio_init。R大写只不过是封装函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//用rio_t作为参数的，有缓冲的。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio_readinitb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio_t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;rio_read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;rio_readnb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//与下面的readline函数可以混合使用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio_readlineb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//用fd作为参数的，无缓冲的。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rio_readn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;write函数都只需要fd。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入一个文件描述符的时候&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实writen和write都是差不多的，只不过writen会检查是否全部write进去了，因为在网络传输，等情况下的时候，可能不会安装设置n的大小写入n字节，所以writen就是加入了一个循环，如果每个字节都读进去，才会完成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们文件都会有一些元数据(metadata)，例如创建时间，文件类型balabala的，有两个函数可一度去这些数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fstat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;重定向&#34;&gt;重定向&lt;/h2&gt;
&lt;p&gt;Linux shell中的 &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$bowser&lt;/span&gt;&amp;gt; ls &amp;gt; foo.txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dup2函数，cgi编程会利用此函数，将std_out重定向到client_sockfd&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dup2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//如果newfd已经打开，会先关闭它。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//一句话：把newtd指向oldfd的文件表项
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//标准输入重定向到描述符5指向的文件表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;会继承&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;打开文件的文件偏移量。因为指向的是同一个文件表。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;疑问&#34;&gt;疑问&lt;/h2&gt;
&lt;p&gt;明确几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带缓冲函数，就是新建立一个结构，储存了fd(文件描述符)，还有缓冲的字节数组，等等东西，代替fd来使用。&lt;/li&gt;
&lt;li&gt;文件偏移量，也就是移动位置是放在文件表结构上的，这里有一个问题，似乎不能多个进程同时打开一个文件。&lt;/li&gt;
&lt;li&gt;文件元数据(metadata)，文件大小，文件类型放在v-node表上。
&lt;ul&gt;
&lt;li&gt;文件类型，文件中有一个type结构指定，例如文本文件，二进制文件，sockets文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标准库IO是设计为读取文本文件的，所以其他类型文件不合适。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>《天气之子》反映的人生观</title><link>https://bowser1704.github.io/blog/2019/11/02/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%8F%8D%E6%98%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E8%A7%82/</link><pubDate>Sat, 02 Nov 2019 20:30:51 +0800</pubDate><guid>https://bowser1704.github.io/blog/2019/11/02/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E5%8F%8D%E6%98%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E8%A7%82/</guid><description>
&lt;h2 id=&#34;电影中不断出现的-麦田里的守望者&#34;&gt;电影中不断出现的《麦田里的守望者》&lt;/h2&gt;
&lt;p&gt;开头就是一个麦田里的守望者的&lt;code&gt;特写镜头&lt;/code&gt;，就像霍尔顿一样，帆高也是离家出走，十分敏感，胆小，软弱，但是就是不愿意在家中待着，有一堆的理由，首先我认为这就是一个很感性的做法，这带来的后果很大，没有理性的去思考所做的事情会发生什么后果。&lt;/p&gt;
&lt;h3 id=&#34;小资情调的忧伤&#34;&gt;小资情调的忧伤&lt;/h3&gt;
&lt;p&gt;在生活水平一定发展之后，也就是小资产阶级就有了很多忧伤，也就是闲的蛋疼，他们感到平庸，世界的无理性，生命是没有意义的，所以他们想要逃跑，不停地逃跑，去一个没有人认识自己的地方，但其实如果去了另一个地方，还是会认识人，还是想要逃离，这是没有意义的逃离，就像霍尔顿一样最后还是回到家里，帆高也是回到家里，无论怎么逃，你所做的事情，其实没有意义，只是给更多人带来更多的麻烦。&lt;/p&gt;
&lt;p&gt;片中提到很多次，圭介和帆高很相似，对，他们其实就是一个少年，一个中年而已，但是表示出来了，都是离家出走，中年的圭介已经妥协了，不愿意麻烦别人，不愿意被别人麻烦，不再是一个感性的存在（但是片子最后他还是感性了），而少年的帆高，无论发生多大的事情，闯了多大的祸，依旧，依旧是没有后悔，没有紧张，当然这是片子刻意不去表现出来正常人的反应，也正是这样，感性的存在深刻的表现出来，也正是许多二次元爱好者的生活态度。&lt;/p&gt;
&lt;p&gt;许多人，中间比较突出的是很多二次元爱好者，家庭生活条件优越，但是可能会有家庭不完整的情况，她们尤其爱这中生活态度，对事物感到忧伤，很容易忧郁，并且喜欢把这种态度宣扬出去，告诉别人自己的状态，我认为这种态度是不正常的，或者说是幼稚的，你小时候17,8岁时候这样我都可以理解，但是如果你长大了，你认为你自己长大了，请不要再去宣扬你这种想法了，你可以忧郁，可以悲伤，但是满世界说你的悲伤是为了什么呢？你要做的还是得做，你的工作还是要完成，既然是生活，都是为了死亡，过程要完整。&lt;/p&gt;
&lt;h2 id=&#34;天气&#34;&gt;天气&lt;/h2&gt;
&lt;p&gt;天气在这里很重要，阳菜可以改变天气，让世界更美好，让人们更加开心，父亲可以带生病的孩子快乐游玩，商家可以卖更多货物&amp;hellip;&amp;hellip;..，总有那么些人会让世界更美好，有更多的欢声笑语，让本来到处逃跑的帆高，开始向往生活，开始认真的面对这个世界，似乎不再那么软弱了，想起葛优在《不见不散》中说的，这可能就是==爱情的力量吧==，圭介也变得更加好，接回了女儿，影片的结尾，他似乎过上了更好的生活，一切都是那么美好，看上去很融洽，大团圆结局。&lt;/p&gt;
&lt;p&gt;但是在这种美好中，带有那么一丝丝的悲伤，这或许就是小资产阶级的忧伤吧，东京成了一个海，或许他以前是那样的，但是让他变回去又付出了多大的代价呢，但是如果牺牲阳菜的话，情况又是怎么样呢，毕竟世界是那么肮脏，如果人们知道阳菜能改变这些，那他也许会被强迫牺牲吧。&lt;/p&gt;
&lt;p&gt;另外，天气，晴天，就比雨天好吗？&lt;/p&gt;
&lt;p&gt;下起了雨，你感到冷吗？&lt;/p&gt;
&lt;h2 id=&#34;所以为的爱情&#34;&gt;所以为的爱情&lt;/h2&gt;
&lt;p&gt;很多女生喜欢这种爱情，彼此之间，无所畏惧，帆高为了阳菜义无反顾，无所畏惧，看上去很美，看上去很感人的，这就是感性，帆高似乎最后得到了爱情，阳菜过上了幸福的生活，我所认为的不是，阳菜必须要牺牲自己，为了大家，为了世界，没必要，每个人都是一个个体，独立的个体，我们要做的是，不去麻烦别人，但是也不用被别人麻烦，甚至是贡献生命，我所以为的爱情没有这种轰轰烈烈，万物瞩目，平平淡淡其实才是最真的，不用打扰谁，如果你们有爱情，那就在一起，仅此，而已。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;其实这是一篇带有反思的文字，我想不明白，为什么我会那样忧郁，悲观，我是农村人，没有优越的生活环境，小县城没有星巴克，生活中没有耐克阿迪，总是感受那些莫名的忧伤，奇怪了，事情变得复杂了，以前喜欢到处宣扬自己的那种忧伤，但是后来慢慢发现，这是很错误的，其实就是渴望被人发现自己，把丧看作是很好的文化，现在丧文化越来越流行，也让我更多的反思自己，自己到底是在做什么，在想什么？&lt;/p&gt;
&lt;p&gt;过度的随性所欲，过度的丧，都是十分感性的表现，如果要to be better，请保持理性。&lt;/p&gt;</description></item><item><title>利用systemd管理nginx.service</title><link>https://bowser1704.github.io/note/2019/11/01/%E5%88%A9%E7%94%A8systemd%E7%AE%A1%E7%90%86nginx.service/</link><pubDate>Fri, 01 Nov 2019 14:50:23 +0800</pubDate><guid>https://bowser1704.github.io/note/2019/11/01/%E5%88%A9%E7%94%A8systemd%E7%AE%A1%E7%90%86nginx.service/</guid><description>
&lt;h2 id=&#34;systemd是什么&#34;&gt;systemd是什么&lt;/h2&gt;
&lt;p&gt;以前的Linux系统启动，首先会启动一个init.d，然后其他所有的进程都是这个进程的子进程，但是现在的改进，启用systemd来启动管理daemon进程，不过据说有一堆的bug、&lt;/p&gt;
&lt;p&gt;systemd具有一系列的命令，但是我只讲systemctl。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;systemctl start nginx.service
systemctl stop nginx.service
systemctl restart nginx.service&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字面意思。&lt;/p&gt;
&lt;h2 id=&#34;如何让systemd托管我们的service&#34;&gt;如何让systemd托管我们的service&lt;/h2&gt;
&lt;p&gt;linux下一切皆文件，systemd也是靠读取一些指定的文件来管理的，我的系统service文件在&lt;code&gt;lib/systemd/system&lt;/code&gt;下面，你可以自己去找一下，locate命令就可以。&lt;/p&gt;
&lt;p&gt;而service长什么样子呢？以nginx.service为例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Unit&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;Description&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;nginx - high performance web server.
&lt;span class=&#34;nv&#34;&gt;Documentation&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;http://nginx.org/en/docs/
&lt;span class=&#34;nv&#34;&gt;After&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;network.target remote-fs.target nss-lookup.target
&lt;span class=&#34;c1&#34;&gt;# 这里是一些描述信息，不是特别重要&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Service&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;Type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;forking
&lt;span class=&#34;nv&#34;&gt;PIDFile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/run/nginx.pid &lt;span class=&#34;c1&#34;&gt;#pid文件的位置&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;ExecStartPre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf &lt;span class=&#34;c1&#34;&gt;#启动前的命令一般都是test，其实就是nginx的命令&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;ExecStart&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf &lt;span class=&#34;c1&#34;&gt;#启动命令，使用绝对路劲。&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;ExecReload&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx -s reopen
&lt;span class=&#34;nv&#34;&gt;ExecStop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/usr/local/nginx/sbin/nginx -s stop
&lt;span class=&#34;nv&#34;&gt;PrivateTmp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Install&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nv&#34;&gt;WantedBy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;multi-user.target
&lt;span class=&#34;c1&#34;&gt;# 放入multi-user.target目录下面&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;nginx配置&#34;&gt;nginx配置&lt;/h2&gt;
&lt;p&gt;我们在安装nginx的时候，如果是默认包管理器安装的话，会自动加入systemd，但是我们自己安装就会有一堆问题。所以conf配置添加一句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;pid /run/nginx.pid
&lt;span class=&#34;c1&#34;&gt;# pid /var/run/nginx.pid&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# /var/run其实是一个指向/run的软连接。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;可能会遇到的问题&#34;&gt;可能会遇到的问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;nginx 找不到nginx.pid，那你就自己去创建一个nginx.pid。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>短链接的实现</title><link>https://bowser1704.github.io/blog/2019/10/31/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 31 Oct 2019 23:57:33 +0800</pubDate><guid>https://bowser1704.github.io/blog/2019/10/31/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>
&lt;h2 id=&#34;什么是短链接&#34;&gt;什么是短链接&lt;/h2&gt;
&lt;p&gt;就是你经常在手机短信，或者微博上看到的URL，都是很短的并且像t.cn这种开头的，限制字数，短信发送按字数收费，微博限制回复长度等等。&lt;/p&gt;
&lt;h2 id=&#34;首先大概的实现思路&#34;&gt;首先大概的实现思路&lt;/h2&gt;
&lt;p&gt;知乎上有很多回答，典型的错误回答有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用MD5等hash直接得出定长字符，没有考虑冲突的情况，在这种情况下冲突是很严重的，不可以忍受的。&lt;/li&gt;
&lt;li&gt;自己&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确的实现方法是，利用进制转化，也就是低进制转换为高进制，数的长度会变得很小，例如1000(2) = 8(10)，一下子就去掉了三位。&lt;/p&gt;
&lt;p&gt;所以给每个长url一个自增10进制id，然后用10进制id转换为62进制，为什么62进制呢？因为10个阿拉伯数字+26×2个英文字母，共62位，这样的话，6位62进制数字也就有了500多亿个，也够用了。&lt;/p&gt;
&lt;h2 id=&#34;长链每次返回的都是同一个短链怎么实现的呢&#34;&gt;长链每次返回的都是同一个短链怎么实现的呢？&lt;/h2&gt;
&lt;p&gt;比较好的方法，建立一个hash-table，存在redis里面很好，长链作为key，短链作为value，并且设置一个过期时间，如果有人再次同一长链转为短链，则返回原来短链，并且把过期时间变长等等。&lt;/p&gt;
&lt;h2 id=&#34;使用短链接过程&#34;&gt;使用短链接过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;向dns请求短链服务的ip，并访问。&lt;/li&gt;
&lt;li&gt;短链接直接返回302/301 重定向到你自己的url&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：302/301都为重定向&lt;/p&gt;
&lt;p&gt;301 redirect: 301 代表永久性转移(Permanently Moved)
302 redirect: 302 代表暂时性转移(Temporarily Moved )&lt;/p&gt;
&lt;p&gt;我认为这里我们是要返回301的也就是永久重定向，因为我们不会再回去访问短链服务了&lt;/p&gt;
&lt;p&gt;但是301的话无法统计这个短链接被访问的时候次数，也就是不能看到这个数据，但其实还是很有用的。所以很多情况还是使用302的。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>谈谈系统启动发生了什么</title><link>https://bowser1704.github.io/blog/2019/08/22/%E8%B0%88%E8%B0%88%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link><pubDate>Thu, 22 Aug 2019 16:23:18 +0800</pubDate><guid>https://bowser1704.github.io/blog/2019/08/22/%E8%B0%88%E8%B0%88%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid><description>&lt;p&gt;系统启动实际上东西比较多，这里只是讲一讲，系统引导方面的东西。&lt;/p&gt;
&lt;h3 id=&#34;0-杂谈&#34;&gt;0. 杂谈&lt;/h3&gt;
&lt;p&gt;首先我们知道在系统中启动叫做&lt;code&gt;boot&lt;/code&gt;，取自Bootstrap，这里有个小故事&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bootstrap不是鞋带的意思，应该是“鞋子背带”的意思（&lt;a href=&#34;http://en.wiktionary.org/wiki/bootstrap）&#34;&gt;http://en.wiktionary.org/wiki/bootstrap）&lt;/a&gt;
在这里隐喻表示一种不需要外部帮助自己能够处理事情的情形。“pull oneself up by one&amp;rsquo;s bootstraps”最初来自于《The Surprising Adventures of Baron Munchausen》这本书里的一个故事：主人公Baron Munchausen不小心掉进了一片沼泽，他通过自己的bootstraps将自己拉了出来（当然有童话神奇的色彩）。事实上在19世纪初美国就有&amp;rdquo;pull oneself over a fence by one&amp;rsquo;s bootstraps&amp;rdquo;的语言，意思是“做荒谬不可能完成的事情”。
参考：&lt;a href=&#34;http://en.wikipedia.org/wiki/Bootstrapping&#34;&gt;http://en.wikipedia.org/wiki/Bootstrapping&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么说这个故事呢，我们要启动系统，就要启动程序对吧，但是启动程序又要系统，这不就是一个死循环了吗？所以&lt;code&gt;一种不需要外部帮助自己能够处理事情的情形&lt;/code&gt;，在当时ROM（Read only memory）的发展下，人们刚开始发明了BIOS（Basic Input/Output System），后来又出现了&lt;code&gt;UEFI&lt;/code&gt;全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)。&lt;/p&gt;
&lt;h3 id=&#34;1-最开始是如何加载系统的&#34;&gt;1. 最开始是如何加载系统的&lt;/h3&gt;
&lt;h4 id=&#34;1-1-老一代的legacy-bios-mbr&#34;&gt;1.1 老一代的Legacy BIOS + &lt;code&gt;MBR&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;最初的启动就是按下电源键之后，电脑读取写入ROM的BIOS。BIOS开始下面几个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件自检（Power-On Self-Test）简称为 POST，如果有问题计算机会发出不同含义的蜂鸣声。（有没有很傻屌）&lt;/li&gt;
&lt;li&gt;选择启动顺序，现在BIOS开始要运行的权利给下一个device了，但是你电脑可能有多个硬盘，也可能你会插入U盘，所以可能需要你选择一个设备。
&lt;ul&gt;
&lt;li&gt;计算机开始读取设备的第一个扇区，也就是512字节，就叫做&amp;rdquo;主引导记录&amp;rdquo;（Master boot record，缩写为&lt;code&gt;MBR&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;但是&lt;code&gt;MBR&lt;/code&gt;有一些问题，所以现在基本不用了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从硬盘启动，加载系统内核相关的东西。
&lt;ul&gt;
&lt;li&gt;这里因为&lt;code&gt;MBR&lt;/code&gt;，所以系统启动读取的是&lt;code&gt;MBR&lt;/code&gt;内的启动程序，但是如果你一个硬盘，装了很多的系统，每次装新的系统，后面的启动代码就会覆盖前者的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结的话&lt;code&gt;BIOS&lt;/code&gt;不认识设备，直接硬的来，你的&lt;code&gt;MBR&lt;/code&gt;内写了什么，他就是什么。&lt;/p&gt;
&lt;h4 id=&#34;1-2-进入linux系统之后initd&#34;&gt;1.2 进入Linux系统之后initd&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;加载内核，进入&lt;code&gt;/boot&lt;/code&gt;下找到内核文件，加载。&lt;/li&gt;
&lt;li&gt;开始运行初始化文件&lt;code&gt;/sbin/init&lt;/code&gt;，他的作用是初始化系统环境，&lt;code&gt;init&lt;/code&gt;就是第一个进程，&lt;code&gt;pid&lt;/code&gt;=1&lt;/li&gt;
&lt;li&gt;确定运行级别&lt;/li&gt;
&lt;li&gt;加载开机启动程序&lt;/li&gt;
&lt;li&gt;用户登录&lt;/li&gt;
&lt;li&gt;进入login shell&lt;/li&gt;
&lt;li&gt;打开 non-login shell&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里初略讲，详情看阮一峰的文章。&lt;/p&gt;
&lt;p&gt;阮一峰写了两篇文章对于以前的启动方式很好的讲解了&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/02/booting.html&#34;&gt;http://www.ruanyifeng.com/blog/2013/02/booting.html&lt;/a&gt; 参考文章，作者阮一峰，对于&lt;code&gt;MBR&lt;/code&gt;的详细解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&#34;&gt;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&lt;/a&gt; 参考文章，作者阮一峰，对于&lt;code&gt;Linux&lt;/code&gt;内核启动的解释。&lt;/p&gt;
&lt;h3 id=&#34;2-今天我们怎么加载系统&#34;&gt;2. 今天我们怎么加载系统&lt;/h3&gt;
&lt;h4 id=&#34;2-1-新时代的-uefi-bios-gpt&#34;&gt;2.1 新时代的&lt;code&gt;UEFI BIOS&lt;/code&gt;+&lt;code&gt;GPT&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UEFI&lt;/code&gt;不同于legacy BIOS的是，他认识设备，他会在&lt;code&gt;/boot/efi&lt;/code&gt;寻找以&lt;code&gt;.efi&lt;/code&gt;为后缀的文件，里面有一个目录&lt;code&gt;EFI&lt;/code&gt;，放了各种系统的&lt;code&gt;efi&lt;/code&gt;启动程序。&lt;/p&gt;
&lt;p&gt;例如（不同厂商的驱动放在不同厂家的文件夹下面）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启动windows 进入Microsoft/Boot/*.efi&lt;/p&gt;
&lt;p&gt;启动&lt;code&gt;ubuntu&lt;/code&gt; 进入ubuntu/*.efi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/4072641-4b58e0e13c209d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/345/format/webp&#34; alt=&#34;efi&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;流程&#34;&gt;流程&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;POST，硬件自检&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UEFI&lt;/code&gt;固件加载，一系列初始化。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按照设置里面的顺序，读取&lt;code&gt;efi&lt;/code&gt;启动项，加载硬件驱动，解析其中的分区表（GPT和MBR）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;启动项分为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件启动项，即&lt;code&gt;UEFI&lt;/code&gt;已经记录了启动项的地址，某个磁盘-&amp;gt;某个分区-&amp;gt;/&lt;code&gt;EFI/Boot/*.efi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设备启动项，就是磁盘，会直接去磁盘里面寻找&lt;code&gt;ESP&lt;/code&gt;分区下的&lt;code&gt;/EFI/Boot/*.efi&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;随着Windows8.x，以及UEFI标准2.x，win推出了一个叫做SecureBoot的功能。开了SecureBoot之后，主板会验证即将加载的efi文件的签名，如果开发者不是受信任的开发者，就会拒绝加载。
比如CloverX64.efi就好像没有签名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以在装Linux的时候我们会关闭SecureBoot，防止不被授权，无法加载efi&lt;/p&gt;
&lt;h5 id=&#34;磁盘分区-文件系统&#34;&gt;磁盘分区，文件系统&lt;/h5&gt;
&lt;p&gt;磁盘就是我们用的硬盘，U盘之类的，我们要对磁盘进行分区，其实不分区可以理解为只分一个区，然后每个区要进行格式化，并且选择文件系统。不同类型磁盘有不同类型的设备驱动，不同系统有不同的文件系统驱动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘驱动
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;win8/10&lt;/code&gt;含有&lt;code&gt;IDE/SATA/NVME&lt;/code&gt;三种驱动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;macos&lt;/code&gt;含有&lt;code&gt;/SATA/NVME&lt;/code&gt;驱动，但是10.13之前是苹果专用&lt;code&gt;NVME&lt;/code&gt;驱动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;文件系统驱动
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;win10&lt;/code&gt;含有FAT32、NTFS、exFAT、ReFS几种&lt;/li&gt;
&lt;li&gt;Linux含有ext2、ext3、ext4、FAT32等&lt;/li&gt;
&lt;li&gt;macOS含有FAT32、HFS+、APFS、exFAT，NTFS只读&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;驱动是可以后期安装的，Paragon这个公司推出了NTFS for Mac、HFS for Windows、ExtFS for……等一套文件系统驱动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结&lt;/h5&gt;
&lt;p&gt;UEFI规范里，在GPT分区表的基础上，规定了一个EFI系统分区（EFI System Partition，ESP），ESP要格式化成FAT32，EFI启动文件要放在“/EFI&amp;lt;厂商&amp;gt;”文件夹下面。&lt;strong&gt;但是Apple比较特殊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为UEFI标准里，钦定的文件系统，FAT32.efi是每个主板都会带的。所有UEFI的主板都认识FAT32分区。这就是为啥非得是FAT32的。&lt;/p&gt;
&lt;p&gt;至于GPT（GUID Partition Table，缩写：GPT），可以理解为新时代的&lt;code&gt;MBR&lt;/code&gt;，分区表。&lt;/p&gt;
&lt;p&gt;所以说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装系统可以不用制作启动盘了，将iso文件压缩到一个FAT32分区内，&lt;del&gt;然后在将该分区下的&lt;code&gt;EFI/Boot/BOOTx64&lt;/code&gt;添加到UEFI文件启动项&lt;/del&gt;，直接进入UEFI引导，就可以选择这一项启动。&lt;/p&gt;
&lt;p&gt;另外UEFI为了兼容MBR，是可以用的，但是Lgacy不支持GPT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2-2-systemd启动系统&#34;&gt;2.2 Systemd启动系统&lt;/h4&gt;
&lt;p&gt;init启动系统有几点不好&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行启动，启动时间长&lt;/li&gt;
&lt;li&gt;启动脚本复杂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Systemd是用来替代init启动而生的，读作 System daemon（系统，守护进程）。&lt;/p&gt;
&lt;p&gt;Systemd是一组命令，涉及到系统管理的方方面面，本来我们启动系统是用initd初始化一个pid=1的进程，然后所有进程都是他的子进程，但是现在的话我们不需要，直接启动Systemd，用它来管理系统。&lt;/p&gt;
&lt;p&gt;这个时候就和上面类似了。但是我们要重点关注&lt;code&gt;systemd&lt;/code&gt;命令组。这里就会体现Linux下一切皆文件的思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ccnupp.oss-cn-shanghai.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.svg&#34; alt=&#34;未命名文件&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;这里还要提一点-系统进入之后&#34;&gt;这里还要提一点，系统进入之后&lt;/h4&gt;
&lt;p&gt;首先我们会进入login shell，这个时候会读取一些配置文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#命令行登录&lt;/span&gt;
~/.bash_profile
~/.bash_login
~/.profile &lt;span class=&#34;c1&#34;&gt;#这里有语句会同时执行.bashrc&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#只要读取了上面一个，就不会再读取后面的了，按上述顺序读取。&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;#图形界面登录的话,只会读取下面两个，不管是否有.bash_profile存在&lt;/span&gt;
etc/ptofile &lt;span class=&#34;c1&#34;&gt;#这个是对于所有用户的配置文件，~/.bashrc是对于当前用户的。&lt;/span&gt;
~/.profile&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们手动开启的shell叫做non login shell，他就会读取.bashrc&lt;/p&gt;
&lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-lpic1-101-2/index.html&#34;&gt;https://www.ibm.com/developerworks/cn/linux/l-lpic1-101-2/index.html&lt;/a&gt; IBM，引导系统&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/02/booting.html&#34;&gt;http://www.ruanyifeng.com/blog/2013/02/booting.html&lt;/a&gt; 参考文章，作者阮一峰，对于MBR的详细解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&#34;&gt;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&lt;/a&gt; 参考文章，作者阮一峰，对于Linux内核启动的解释。&lt;/p&gt;
&lt;p&gt;关于systemd使用，这里有几篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html&#34;&gt;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html&lt;/a&gt; 作者：阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html&#34;&gt;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html&lt;/a&gt; 作者：阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/Systemd_&lt;/a&gt; 来源Archwiki&lt;/p&gt;</description></item><item><title/><link>https://bowser1704.github.io/draft/anyway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bowser1704.github.io/draft/anyway/</guid><description>&lt;p&gt;当事情变得奇怪起来的时候，你也会变的奇怪&lt;/p&gt;
&lt;p&gt;说实话有一些陌生，但是那又能怎么办呢？&lt;/p&gt;
&lt;p&gt;我没有办法，只能没有选择的，妥协，但是我要坚持，我要去做，做所有的事情，就是这样，人太多，事情太杂，太乱，太多，&lt;/p&gt;</description></item><item><title/><link>https://bowser1704.github.io/draft/malloc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bowser1704.github.io/draft/malloc/</guid><description>
&lt;p&gt;几种在堆上分配内存的方式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;calloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nmemb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;realloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;reallocarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nmemb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;1-malloc&#34;&gt;1. malloc&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n为要分配的字节数&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数必须配合memset初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;memset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;2-calloc&#34;&gt;2. calloc&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;calloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n为要分配的元素个数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size为元素所占的字节数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数默认初始化都为0，不需要memset手动初始化，适合用于数组创建。&lt;/p&gt;
&lt;h3 id=&#34;3-realloc&#34;&gt;3. realloc&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;realloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//p是堆上一块内存的地址，也就是我们分配的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//n是我们将p指向的内存空间大小字节数设置为n，新起一块大小为n的内存，并且将数据给复制过去。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;但是如果&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p指向的内存空间大于或等于n&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，不变。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;4-free&#34;&gt;4. free&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//释放该指针所指向的内容，但是该指针还是存在的，其实他是在栈上的，只不过指向的空间是在堆上。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//所以我们为了不让她成为野指针，我们再释放p后，设p为NULL；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//free(p);
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;5-reallocarray&#34;&gt;5. reallocarray&lt;/h3&gt;
&lt;p&gt;The reallocarray() function changes the size of the memory block pointed to by ptr to be large enough for an array of nmemb elements,
each of which is size bytes. It is equivalent to the call&lt;/p&gt;
&lt;p&gt;&lt;code&gt;realloc(ptr, nmemb * size);&lt;/code&gt;
However, unlike that realloc() call, reallocarray() fails safely in the case where the multiplication would overflow. If such an over‐flow occurs, reallocarray() returns NULL, sets errno to ENOMEM, and leaves the original block of memory unchanged.&lt;/p&gt;</description></item><item><title>关于</title><link>https://bowser1704.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://bowser1704.github.io/about/</guid><description>
&lt;h2 id=&#34;关于我自己&#34;&gt;关于我自己&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个还在读本科的垃圾cser。&lt;/li&gt;
&lt;li&gt;我喜欢看电影，看书，但是没有影评，也没有书评，对的我就是这么垃圾，混混pt站。&lt;/li&gt;
&lt;li&gt;喜欢读诗，读的难听，写的难看。&lt;/li&gt;
&lt;li&gt;对政治，没有明确观点，&lt;/li&gt;
&lt;li&gt;“厌恶”感性，保持理性，人生是十分短暂的，世界也不是那么的美好，感性会让这个世界变得更加混乱，没有正常的逻辑，并且那对于其他人是很不公平的，说白了就是我厌恶十分感性的人，让事情变得复杂起来，所以对一切事物都要保持理性，实际上人类都很垃圾，都很失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的邮箱是&lt;a href=&#34;#&#34; class=&#34;cryptedmail&#34;
data-name=&#34;bowser1704&#34;
data-domain=&#34;icloud&#34;
data-tld=&#34;com&#34;
onclick=&#34;window.location.href = &#39;mailto:&#39; + this.dataset.name + &#39;@&#39; + this.dataset.domain + &#39;.&#39; + this.dataset.tld; return false;&#34;&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;写作原则&#34;&gt;写作原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不抄袭，不复制粘贴，不炒冷饭，不写已经有很好的文章的东西。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量避免废话，精简。😈&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>