---
title: "Note Draft"
date: 2019-08-24T11:25:24+08:00
draft: true
---

### First

1. 小贴士： 像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前边需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前边需要加双短划线。后边会详细讨论这些参数的使用方式的.

2. 如果你非要在一行命令中显式的把密码输出来，那-p和密码值之间不能有空白字符（其他参数名之间可以有空白字符）

3. 小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

4. 小贴士： 如果某个客户端改变了某个系统变量在`GLOBAL`作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为`SESSION`的值，只会影响后续连入的客户端在作用范围为`SESSION`的值。

### 与mysql小册不同的地方

#### mysql.server启动脚本问题

在5.7时候，有两个个脚本叫做mysqld.safe，mysql.server，并且有一个链接 ../support-files/mysql.server。

但是在8.0，没有发现有这个东西存在。

#### unix scoket通信

如果我们的服务器进程和客户端进程都运行在同一台操作系统为类Unix的机器上的话，我们可以使用Unix域套接字文件来进行进程间通信.

有两种情况，会触发，一是--host=localhost，默认就是， 二是 --protocol=socket，套接字文件路径在

`'/var/run/mysqld/mysqld.sock'`

如果我们想改变这个默认路径，可以在启动服务器程序时指定socket参数，就像这样:

`mysqld --socket = /tmp/a.sock`

#### 字符集环境变量问题	Q

character_set_connection`只是服务器在处理请求时使用的字符集，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求以及结果集中的字符，要不然会出现无法将请求中的字符编码成`character_set_connection`字符集或者无法编码结果集中的字符。

？应该要和database，table...中的字符集是一样的，否则会出问题。

### mysql小册笔记

#### InnoDB

1. InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取`16KB`的内容到内存中，一次最少把内存中的`16KB`内容刷新到磁盘中。
2. 在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！
3. 对于 ***CHAR(M)*** 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。
4. 那发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？MySQL中规定一个页中至少存放两行记录
5. 一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！
6. **InnoDB的表空间定义太多，没看懂，要回去复习**

### 查找方式

**Q：重点是可以通过next_record找到每一个记录的位置**

**A：因为我们知道最小记录和最大记录的地址，所以根据头尾地址都知道，中间有相对地址偏移量，所以我们可以知道每一个记录的位置**

记录头信息`heap_no`表示当前记录在记录堆的位置信息 13个字节。

每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。并且是有序的，按照primary_key来排序，但是储蓄不一定有序。

每一页有固定的两个记录，Infimum和Supermum，最大记录的next_record为0，最小记录的next_record为真实记录最小的偏移量。**最小记录，最大记录的位置字节大小都是固定的**

每一页有一个Page directory，记录每个slot最后一个数据的next_record属性。最后一个slot放的就是最大的主键的偏移量，这个是是针对最大记录的偏移量。

在每一页有一个Page Header信息，里面有很多字段，其中有三个。

|                    |              |                                        |
| :----------------: | :----------: | :------------------------------------: |
|        名称        | 占用空间大小 |                  描述                  |
| `PAGE_N_DIR_SLOTS` |    2字节     |            页目录的slot数量            |
| `PAGE_LAST_INSERT` |    2字节     |           最后插入记录的地址           |
|   `PAGE_N_RECS`    |    2字节     | 该页中记录的数量（不含最大最小已删除） |

所以我们是怎么根据主键怎么查找的呢？

我们现在知道PAGE_LAST_INSERT，和最后一个槽的指向，就可以知道每一个记录的地址。

首先知道slot的数量，利用二分法，寻找所在数据是哪一个slot内的，然后通过next_record遍历，去寻找。

### 连接

连接分为内连接和外连接。

- 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的内连接。

- 对于外连接的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

- 在MySQL中，根据选取驱动表的不同，外连接仍然可以细分为2种：
  - 左外连接

    选取左侧的表为驱动表。

  - 右外连接

    选取右侧的表为驱动表。

