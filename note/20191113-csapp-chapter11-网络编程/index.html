<!DOCTYPE html>
<html lang="zh-CN"><meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="referrer" content="no-referrer">
<meta name="renderer" content="webkit">
<meta name="force-rendering" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-transform">
<meta name="format-detection" content="telephone=no,email=no,address=no">
<meta name="generator" content="Hugo 0.70.0" />


<title>csapp Chapter11 网络编程 - Bowser</title>


<link rel="stylesheet" href="/css/style.css">

<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:400,700&display=swap&subset=chinese-simplified" rel="stylesheet" />
<link rel="canonical" href="https://bowser1704.github.io/note/20191113-csapp-chapter11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
<link rel="shortcut icon" href="/favicon.jpg">

<meta itemprop="name" content="csapp Chapter11 网络编程">
<meta itemprop="description" content="csapp 第11章网络编程">
<meta itemprop="datePublished" content="2019-11-13T21:30:14&#43;08:00" />
<meta itemprop="dateModified" content="2019-11-13T21:30:14&#43;08:00" />
<meta itemprop="wordCount" content="2827">



<meta itemprop="keywords" content="csapp," />
<meta property="og:title" content="csapp Chapter11 网络编程" />
<meta property="og:description" content="csapp 第11章网络编程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bowser1704.github.io/note/20191113-csapp-chapter11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" />
<meta property="article:published_time" content="2019-11-13T21:30:14+08:00" />
<meta property="article:modified_time" content="2019-11-13T21:30:14+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="csapp Chapter11 网络编程"/>
<meta name="twitter:description" content="csapp 第11章网络编程"/>
<body class="font-sans">
    <div class="flex flex-col md:flex-row md:w-4/5 mx-auto py-5 min-h-screen">
<header
    class="flex flex-col relative border-black border-b-4 md:border-b-0 md:border-r-2 pb-6 mx-4 md:mx-0 md:w-1/5 md:text-right md:pr-8 bg-white md:text-center">
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <div>
        <h1 id="header_logo" class="text-3xl md:my-12 mt-4 md:mb-12"><a href="https://bowser1704.github.io">Bowser</a></h1>
        <p class="font-thin italic">null</p>
    </div>
    <input id="menu-check" type="checkbox" class="hidden" />
    <label id="menu-label" for="menu-check"
        class="absolute right-0 text-right md:hidden  inline-block py-4 h-12 cursor-pointer mt-10 text-xl text-gray-900">
        <span class="icon close-icon">✕</span>
        <span class="icon open-icon">☰</span>
        <span class="text">MENU</span>
    </label>
    <nav id="menu" class="my-2 w-full md:flex-row-reverse hidden md:block">
        <ul class="list-none pl-0 mx-auto justify-center  max-w-xs">
            
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/blog/">博客</a>
            </li>
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/note/">笔记</a>
            </li>
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/about/">关于</a>
            </li>
            
        </ul>
    </nav>
</header>
<main class="flex-1 p-4 ">
<article itemscope itemtype="http://schema.org/Article" class="max-w-3xl mx-auto leading-relaxed">
    <header class="flex flex-col meta">
<div class="flex flex-col md:flex-row justify-between ">
    
    <ul class="flex justify-end text-gray-800" itemprop="articleSection">
        
        <li class="pl-2 pr-0 md:pl-0 md:pr-2">
            <a href="/categories/cs" rel="category">cs</a>
        </li>
        
    </ul>
    
    
    <ul class="flex justify-end text-gray-700">
        
        <li itemprop="keywords" class="pl-2 md:pl-4">
            <a href="https://bowser1704.github.io/tags/csapp/">#csapp</a>
        </li>
        
    </ul>
    
</div>
<h1 itemprop="name" class="text-center text-4xl my-4 md:my-6">csapp Chapter11 网络编程</h1>
        
        <h3 class="text-center text-2xl">
            
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
                <span itemprop="name">Bowser</span>
                
                
                 / 
                <span itemprop="datePublished"
                    content="2019-11-13">2019-11-13</span>
                
        </h3>
        
    </header>
    <hr class="block my-10 mx-auto max-w-xs h-px border-t border-black">
    <div itemprop="articleBody" class="content markdown">
        <p>主要记录一下socket相关内容，网络协议不多做描述。</p>
<p>下图是基本的步骤图</p>
<p>



    <img class="mx-auto" alt="" src="https://pic.superbed.cn/item/5dcd2bb58e0e2e3ee9164936.jpg" />
</p>
<h2 id="getaddrinfo">getaddrinfo</h2>
<p>一句话：获取套接字地址，从url，也就是dns获取真正的ip地址，返回的结构中是一个链表，有多个sockaddr(也就是dns会给我们返回多个ip地址)，我们通过遍历来确定哪一个可用，如果都没有用，就error了。</p>
<p>注意点：</p>
<ul>
<li>
<p>sockaddr是socket地址结构，16个字节，前两个字节标明协议簇，后面的字节其实可以变动。</p>
<p>因为IPV4与IPV6一个32位(4个字节)，一个128位(16个字节)，所以sockaddr装不下IPV6，就有sockaddr_in 16个字节，sockaddr_in6 28个字节。但是其实都是可以转化为sockaddr使用，也就是我们使用的就是sockaddr，为什么呢，因为我们每次传参传的是sockaddr指针，并且还有一个sockaddr_len，既然有了长度，结构体底层不一样也没事了，需要的是指针+长度，就可以得到完整数据。</p>
<p>整理一下有几种sockaddr结构</p>
<p>sockaddr            		16 bytes
sockaddr_in        		16 bytes for IPv4
sockaddr_in6        	28 bytes for IPv6
sockaddr_storage    128 bytes for all protocol</p>
</li>
<li>
<p>返回的是addrinfo链表，里面除了sockaddr指针外，还存放了，数据协议，一些可选参数，balabala的。</p>
</li>
<li>
<p>利用它是直接返回addrinfo，我们在socket等函数中可以直接使用这些属性作为参数。</p>
</li>
</ul>
<p>P.S.：csapp中有些函数讲的是全小写，使用时首字母却大写了，例如getaddrinfo，使用时却是Getaddrinfo，其实是做了一个封装。例如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Getaddrinfo</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>node, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>service, 
                 <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> addrinfo <span style="color:#f92672">*</span>hints, <span style="color:#66d9ef">struct</span> addrinfo <span style="color:#f92672">**</span>res)
{
    <span style="color:#66d9ef">int</span> rc;
	<span style="color:#75715e">//加了一个错误处理，其他都差不多
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((rc <span style="color:#f92672">=</span> getaddrinfo(node, service, hints, res)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) 
        gai_error(rc, <span style="color:#e6db74">&#34;Getaddrinfo error&#34;</span>);
}
</code></pre></div><h2 id="client创建">client创建</h2>
<p>getaddrinfo -&gt; socket -&gt; connect ** open_clientfd</p>
<ul>
<li>
<p>getaddrinfo 不多做解释</p>
</li>
<li>
<p>socket 得到一个clientfd，这个时候还没有网络什么事，仅仅是自己创建一个socket fd，内核会动态分配一个port。</p>
</li>
<li>
<p>connect 这个时候开始有网络了，connect里面要填server的sockaddr，记住还有addrlen，这是sockaddr可以适用于不同协议的关键。</p>
</li>
</ul>
<p>open_clientfd是用来替换上面几个步骤的。</p>
<h2 id="server创建">server创建</h2>
<p>getaddrinfo -&gt; socket  -&gt; bind -&gt; listen -&gt; accept</p>
<ul>
<li>
<p>socket+bind+listen 用来创建一个listenfd，** open_listenfd</p>
<ul>
<li>socket 创建一个socket fd，暂时没什么用，参数有协议和一些可选参数。</li>
<li>bind 这个时候bind地址，也就是传入sockaddr和sockaddr_len，确定这个socket绑定什么socket地址，与client不同，前者是动态分配的。</li>
<li>listen 确认这个socket fd 是 listenfd 区分于 connfd(connecting fd)。</li>
</ul>
<p>open_listenfd就是把上面四个步骤整合了，但是还是要手写accept。</p>
</li>
<li>
<p>accept 创建一个connfd，这是真正与client通信的socket，listenfd是用来监听的。</p>
</li>
</ul>
<p><strong>注意一个问题，我们在getaddrinfo的时候hints.ai_flags设置了参数AI_PASSIVE，这是说我们host参数设置为0，也就是发送到本主机的所有ip地址我们都会接受。host值是通配符</strong></p>
<p>也就是说你舍友和你在同一个局域网内，是可以访问到你的。如果你设置了，也就是指定了ip，只有这个满足的ip才可以访问你，可以使用通配符。</p>
<p>这样的话你就可以使用局域网利用http协议和你室友传输文件了。</p>
<h2 id="http">HTTP</h2>
<p>http请求注意格式，头部，实际内容。其实我们往socket里面写的就是字符串，但是是按照http的格式来写的，开头怎么样，头部怎么样，都是约定好的。所以我们解析http请求（注意uri是http请求内的一部分字段），做出不同的响应</p>
<h3 id="静态内容响应">静态内容响应</h3>
<p>根据uri中的文件位置，我们返回文件。（如果是直接/，我们手动定位到home.html文件。），那么文件怎么返回/发送呢</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#75715e">/* Send response body to client */</span>
    <span style="color:#75715e">//打开文件，readonly
</span><span style="color:#75715e"></span>srcfd <span style="color:#f92672">=</span> Open(filename, O_RDONLY, <span style="color:#ae81ff">0</span>);                       

<span style="color:#75715e">//原做法
</span><span style="color:#75715e">//虚拟内存内容相关，将文件/利用文件描述符 映射到一块虚拟空间，srcp。
</span><span style="color:#75715e"></span>srcp <span style="color:#f92672">=</span> Mmap(<span style="color:#ae81ff">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span style="color:#ae81ff">0</span>); 
<span style="color:#75715e">//关闭文件描述符号，已经有了虚拟内存空间上面的映射，不需要再read-&gt;write，防止内存泄露
</span><span style="color:#75715e"></span>Close(srcfd);                                               
<span style="color:#75715e">//写入coonfd，send response body to client
</span><span style="color:#75715e"></span>Rio_writen(fd, srcp, filesize);                             
<span style="color:#75715e">//释放虚拟内存中的空间，防止内存泄露
</span><span style="color:#75715e"></span>Munmap(srcp, filesize);

<span style="color:#75715e">//作业11-9 做法
</span><span style="color:#75715e"></span>srcp <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) malloc(filesize <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
Rio_t rio;
Rio_readinitb(<span style="color:#f92672">&amp;</span>rio, srcfd);
Rio_readnb(<span style="color:#f92672">&amp;</span>rio, srcp, filesize);
<span style="color:#75715e">//上面三步步骤可以用Rio_readn(srcfd, srcp, filesize)无缓冲函数; 直接代替.题目要求这种。
</span><span style="color:#75715e"></span>Rio_writen(fd, srcp, filesize);
free(srcp);
</code></pre></div><p>所以其实还是打开文件，写入另一个文件描述符，就是发送了。</p>
<p><strong>有一个问题：为什么不直接用srcfd，先读取srcfd，到buf，在写入coonfd中。</strong></p>
<p>作业11-9就让你修改这种方式，直接用malloc和rio_readn，rio_writen写入fd</p>
<p><strong>还记得我们上面说可以和室友传输文件吗？但是我们首先要实现支持MPG等视频文件的web</strong></p>
<p>作业11-7就是让我们手写支持MPG视频文件。</p>
<p>我们可以get_filetype加入一个mp4-&gt;viedo/mpge4，但是返回的直接是文件，还没有名字。</p>
<h3 id="动态内容响应-cgi">动态内容响应 cgi</h3>
<p>parse_uri中会将uri中的参数，也就是调用的cgi程序的位置表明出来。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> { <span style="color:#75715e">/* Dynamic content */</span>    
        <span style="color:#75715e">//返回 &#39;?&#39;在uri中出现的index
</span><span style="color:#75715e"></span>        ptr <span style="color:#f92672">=</span> index(uri, <span style="color:#e6db74">&#39;?&#39;</span>); 
        <span style="color:#66d9ef">if</span> (ptr)
        {
            strcpy(cgiargs, ptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>); <span style="color:#75715e">//把？后面的参数copy给cgiargs
</span><span style="color:#75715e"></span>            <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
        }

        <span style="color:#75715e">//不存在?的情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>
            strcpy(cgiargs, <span style="color:#e6db74">&#34;&#34;</span>); 
        <span style="color:#75715e">//下面是把filename变成了.uri(./cgi-bin/adder)，也就是linux下的相对文件名字
</span><span style="color:#75715e"></span>        strcpy(filename, <span style="color:#e6db74">&#34;.&#34;</span>);   
        strcat(filename, uri);   
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">dynamic filename=%s uri=%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, filename, uri);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p>所以我们在cgi中调用如下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#66d9ef">if</span> (Fork() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    { <span style="color:#75715e">/* Child */</span> <span style="color:#75715e">//line:netp:servedynamic:fork
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/* Real server would set all CGI vars here */</span>
        setenv(<span style="color:#e6db74">&#34;QUERY_STRING&#34;</span>, cgiargs, <span style="color:#ae81ff">1</span>);                         
        Dup2(fd, STDOUT_FILENO); <span style="color:#75715e">/* Redirect stdout to client */</span>    
        Execve(filename, emptylist, environ); <span style="color:#75715e">/* Run CGI program */</span> <span style="color:#f92672">/</span>
    }
    <span style="color:#75715e">//等待子进程die，完成后函数才结束
</span><span style="color:#75715e"></span>    Wait(NULL); <span style="color:#75715e">/* Parent waits for and reaps child */</span> 
</code></pre></div><p><strong>有一个问题，上面是直接wait，等待子进程死亡，在结束这个函数，联想一下，异常控制流那一章节，直接处理SIGCHLD信号，回收子进程的操作</strong></p>
<p>也就是作业11-8，怎么操作呢？未定，怎么解决呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ch_signal</span>(<span style="color:#66d9ef">int</span> sig){
    pid_t pid;
    <span style="color:#75715e">//子进程中都还没有终止，就立即返回0.否则返回终止子进程号，这样的话，在等待子进程的时候，我们还是可以做自己的事情的。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>( (pid <span style="color:#f92672">=</span> waitpid(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, NULL, WHOHANG)) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> )
        ;
}
<span style="color:#75715e">//main函数中，加一个
</span><span style="color:#75715e"></span>signal(SIGCHILD, ch_signal);
</code></pre></div><h2 id="注意几点">注意几点</h2>
<ul>
<li>
<p>编译代码时，要加上-lpthread，gcc不再使用老的线程库pthread。</p>
</li>
<li>
<p>CGI是标准</p>
</li>
<li>
<p>http请求如何响应，我们都知道传输的是二进制序列（模拟信号-&gt;数字信号），拿过来之后也只能解析成字符串，那怎么分辩什么是什么呢？</p>
<p>有两种方法，一种是就是每句话后面接上一个<code>\r\n</code>，标识这句话已经说完了，第二种是开头加上一个长度，标识后面这句话的长度是多少。http请求的头部是采用<code>\r\n</code>，而data是采用length的方法，所以你会看到http请求header里面会有一个Content-length字段。</p>
<p>注意最后一个header会有两个“\r\n\r\n”，这是为了区分content和header。</p>
</li>
<li>
<p>我们将congtent-length设置为int，所以传输大文件会出问题。</p>
</li>
</ul>
<p>可以去看我在tiny文件上做的笔记。<a href="https://github.com/Bowser1704/csapp/blob/master/chapter11/tiny.c">tiny.c</a></p>

    </div>
</article>

        </main>
    </div><footer class="flex justify-center">
    <div class="copyright mx-auto my-8">
        <p>
            © 2018-2020 <a href="https://github.com/Bowser1704">Bowser1704</a> - <strong><a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong> - <strong>Power By Hugo | Theme By hugo-w2ng</strong>
        </p>
        
    </div>
</footer>



<script src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script></body>

</html>