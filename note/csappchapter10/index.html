<!DOCTYPE html>
<html lang="zh-CN"><meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="renderer" content="webkit">
<meta name="force-rendering" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="no-transform">
<meta name="format-detection" content="telephone=no,email=no,address=no">
<meta name="generator" content="Hugo 0.70.0" />


<title>csapp Chapter10 UnixIO - Bowser</title>




    
    
    <link rel="stylesheet" href="/css/styles.min.c6b7d8857766555f700f21654ec85cef78aeb17a31dfc0cf50c851e0f7063fd1.css" integrity="sha256-xrfYhXdmVV9wDyFlTshc73iusXox38DPUMhR4PcGP9E=">
    


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:400,700&display=swap&subset=chinese-simplified" rel="stylesheet" />
<link rel="canonical" href="https://bowser1704.github.io/note/csappchapter10/">


<link rel="shortcut icon" href="/favicon.jpg">


<meta itemprop="name" content="csapp Chapter10 UnixIO">
<meta itemprop="description" content="csapp第十章的笔记">
<meta itemprop="datePublished" content="2019-11-12T22:05:45&#43;08:00" />
<meta itemprop="dateModified" content="2019-11-12T22:05:45&#43;08:00" />
<meta itemprop="wordCount" content="1964">



<meta itemprop="keywords" content="csapp," />
<meta property="og:title" content="csapp Chapter10 UnixIO" />
<meta property="og:description" content="csapp第十章的笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bowser1704.github.io/note/csappchapter10/" />
<meta property="article:published_time" content="2019-11-12T22:05:45+08:00" />
<meta property="article:modified_time" content="2019-11-12T22:05:45+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="csapp Chapter10 UnixIO"/>
<meta name="twitter:description" content="csapp第十章的笔记"/>
<body class="font-sans">
    <div class="flex flex-col md:flex-row md:w-4/5 mx-auto py-5 min-h-screen">
<header
    class="flex flex-col relative border-black border-b-4 md:border-b-0 md:border-r-2 pb-6 mx-4 md:mx-0 md:w-1/5 md:text-right md:pr-8 bg-white md:text-center">
    <div>
        <h1 id="header_logo" class="text-3xl md:my-12 mt-4 md:mb-12"><a href="/">Bowser</a></h1>
        <p class="font-thin italic">null</p>
    </div>
    <input id="menu-check" type="checkbox" class="hidden" />
    <label id="menu-label" for="menu-check"
        class="absolute right-0 text-right md:hidden  inline-block py-4 h-12 cursor-pointer mt-10 text-xl text-gray-900">
        <span class="icon close-icon">✕</span>
        <span class="icon open-icon">☰</span>
        <span class="text">MENU</span>
    </label>
    <nav id="menu" class="my-2 w-full md:flex-row-reverse hidden md:block">
        <ul class="list-none pl-0 mx-auto justify-center  max-w-xs">
            
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/blog/">博客</a>
            </li>
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/note/">笔记</a>
            </li>
            
            <li class="my-4 border-black text-center md:text-right border-b-2 md:border-none pb-1">
                <a class="py-4 md:border-black md:border-b-2  md:pb-1" href="/about/">关于</a>
            </li>
            
        </ul>
    </nav>
</header>
<main class="flex-1 p-4 ">
<article itemscope itemtype="http://schema.org/Article" class="max-w-3xl mx-auto leading-relaxed">
    <header class="flex flex-col meta">
<div class="flex flex-col md:flex-row justify-between ">
    
    <ul class="flex justify-end text-gray-800" itemprop="articleSection">
        
        <li class="pl-2 pr-0 md:pl-0 md:pr-2">
            <a href="/categories/cs" rel="category">cs</a>
        </li>
        
    </ul>
    
    
    <ul class="flex justify-end text-gray-700">
        
        <li itemprop="keywords" class="pl-2 md:pl-4">
            <a href="https://bowser1704.github.io/tags/csapp/">#csapp</a>
        </li>
        
    </ul>
    
</div>
<h1 itemprop="name" class="text-center text-4xl my-4 md:my-6">csapp Chapter10 UnixIO</h1>
        
        <h3 class="text-center text-2xl">
            
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
                <span itemprop="name">Bowser</span>
                
                
                 / 
                <span itemprop="datePublished"
                    content="2019-11-12">2019-11-12</span>
                
        </h3>
        
    </header>
    <hr class="block my-10 mx-auto max-w-xs h-px border-t border-black">
    <div itemprop="articleBody" class="content markdown">
        <h2 id="基本概念">基本概念</h2>
<p>首先要有一个思维，Linux上面基本上所有外部设备都是文件，都是通过IO来读取，写入的，包括键盘，网络，终端&hellip;..</p>
<p>P.S.：为什么终端是呢，想象一下以前大型计算机，只有一台主机，不同人使用，就是有多个终端(物理设备)来操作系统，只不过现在我们用的微机就是一台主机了。</p>
<p>



    <img class="mx-auto" alt="上一张图" src="https://pic.superbed.cn/item/5dcabfbd8e0e2e3ee9b257f5.jpg" />
</p>
<p>看这张图片，可以看到：</p>
<ul>
<li>外设都是走I/O总线，从而与系统交互。</li>
</ul>
<h3 id="那怎么使用文件呢">那怎么使用文件呢</h3>
<p>一句话：系统打开文件时会生成两个结构一个是在系统表上，一个是在v-node表上。前者存储的是某个进程对文件读取的偏移量，后者储存的是文件的固有属性，文件大小，文件权限。</p>
<ul>
<li>文件读取的偏移量：你打开一个文件会进行读取，不可能一次读完，也不可能每次读都从头开始，而是记录你上次读到哪里了，这就是偏移量。</li>
</ul>
<p>对于某个进程来说：一个进程会打开多个文件，怎么管理呢？有一张表，叫做描述符表，每个打开的文件都有一个ID，也叫作描述符，你打开文件后，描述符就代表你的文件了。看下面的图</p>
<p>



    <img class="mx-auto" alt="" src="https://pic.superbed.cn/item/5dcac3bc8e0e2e3ee9b6fc15.png" />
</p>
<ul>
<li>子进程继承父进程的文件，有自己的描述符，但是指向相同的文件表。</li>
<li>一个进程打开两次同一个文件，会有两个描述符，但是同一个文件表结构。</li>
<li>文件表结构只有refcnt=0才会关闭，也就是引用他的文件描述符为0，才会关闭。</li>
</ul>
<p>P.S.：每个进程会默认打开三个文件，有三个描述符 0=标准输入(Stdin)，1=标准输出(Stdout)，2=标准错误(Stderr)</p>
<table>
<thead>
<tr>
<th align="center">整数值</th>
<th align="center">名称</th>
<th align="center">unistd.h符号常量[<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6#cite_note-1">1]</a></th>
<th align="center">stdio.h文件流[<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6#cite_note-2">2]</a></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stdin">Standard input</a></td>
<td align="center">STDIN_FILENO</td>
<td align="center">stdin</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stdout">Standard output</a></td>
<td align="center">STDOUT_FILENO</td>
<td align="center">stdout</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/Stderr">Standard error</a></td>
<td align="center">STDERR_FILENO</td>
<td align="center">stderr</td>
</tr>
</tbody>
</table>
<h2 id="unix-io">Unix IO</h2>
<p>打开文件用到了open函数返回的是文件描述符，注意两个参数</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">open</span>(<span style="color:#458;font-weight:bold">char</span> <span style="color:#000;font-weight:bold">*</span>filename, <span style="color:#458;font-weight:bold">int</span> flags, mode_t mode);
<span style="color:#998;font-style:italic">//flags是进程如何访问这个文件，只读还是只写，或者不存在时新建
</span><span style="color:#998;font-style:italic">//mode是创建文件时指定权限，就是正常的文件权限，读写执行，这里有一个umask，
</span><span style="color:#998;font-style:italic">//每个进程都有一个umask，通过umask函数执行，真正的mode为 mode &amp; ~umask
</span><span style="color:#998;font-style:italic">//出错返回-1 否则返回文件描述符
</span><span style="color:#998;font-style:italic"></span>ssize_t <span style="color:#900;font-weight:bold">read</span>(<span style="color:#458;font-weight:bold">int</span> fd, <span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>buf, size_t n);
ssize_t <span style="color:#900;font-weight:bold">write</span>(<span style="color:#458;font-weight:bold">int</span> fd, <span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">void</span> <span style="color:#000;font-weight:bold">*</span>buf, size_t n);
</code></pre></div><p>读和写文件，Unix IO读写文件都是无缓冲的，也就是说每次读文件，都要陷入内核态，按照指定的字节大小读取放到给定的字符指针内，如果遇到EOF就返回0，否则返回读取字节大小，出错返回-1。</p>
<ul>
<li>ssize_t与size_t，前者是signed，因为可能返回-1，后者是unsigned，读取字节数&gt;=0。</li>
<li>EOF，指的是当当前文件位置指向文件的最后，也就是文件偏移量等于文件长度时候，引发的end-of-file。并不实际存在这个东西。</li>
</ul>
<h2 id="rio与标准库io">RIO与标准库IO</h2>
<p>这些函数有些事要是有缓冲区的，怎么实现的呢，就是新建一个缓冲结构，每次调用Unix IO时尽可能的读取足够多的字节(等于缓冲区大小)，陷入内核态费时间，这样的话，如果下次再读，直接去缓冲区拿(空间换时间)。</p>
<p>标准库io也是格式化输入输出，并且也有缓冲区，但是也有很多问题，不适合在网络编程上使用，</p>
<p>这里就是一些函数，去看书，看具体实现。</p>
<p><strong>要理解我们read文件的时候有才需要有缓冲，write文件的时候缓冲意义就不大了。</strong></p>
<ol>
<li>
<p>rio read函数分为两批，参数不同，rio_t作为参数要先rio_init。R大写只不过是封装函数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#998;font-style:italic">//用rio_t作为参数的，有缓冲的。
</span><span style="color:#998;font-style:italic"></span>rio_readinitb(rio_t <span style="color:#000;font-weight:bold">*</span>rp, <span style="color:#458;font-weight:bold">int</span> fd);
rio_read();
rio_readnb();<span style="color:#998;font-style:italic">//与下面的readline函数可以混合使用
</span><span style="color:#998;font-style:italic"></span>rio_readlineb();
<span style="color:#998;font-style:italic">//用fd作为参数的，无缓冲的。
</span><span style="color:#998;font-style:italic"></span>rio_readn();
</code></pre></div><p>write函数都只需要fd。</p>
</li>
<li>
<p>写入一个文件描述符的时候</p>
<p>其实writen和write都是差不多的，只不过writen会检查是否全部write进去了，因为在网络传输，等情况下的时候，可能不会安装设置n的大小写入n字节，所以writen就是加入了一个循环，如果每个字节都读进去，才会完成。</p>
</li>
<li>
<p>我们文件都会有一些元数据(metadata)，例如创建时间，文件类型balabala的，有两个函数可一度去这些数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">stat</span>(<span style="color:#000;font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="color:#000;font-weight:bold">*</span> filename, <span style="color:#000;font-weight:bold">struct</span> stat <span style="color:#000;font-weight:bold">*</span>buf);
<span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">fstat</span>(<span style="color:#458;font-weight:bold">int</span> fd, <span style="color:#000;font-weight:bold">struct</span> stat <span style="color:#000;font-weight:bold">*</span>buf);
</code></pre></div></li>
</ol>
<h2 id="重定向">重定向</h2>
<p>Linux shell中的 <code>&gt;</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#008080">$bowser</span>&gt; ls &gt; foo.txt
</code></pre></div><p>dup2函数，cgi编程会利用此函数，将std_out重定向到client_sockfd</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">dup2</span>(<span style="color:#458;font-weight:bold">int</span> oldfd, <span style="color:#458;font-weight:bold">int</span> newfd);
<span style="color:#998;font-style:italic">//如果newfd已经打开，会先关闭它。
</span><span style="color:#998;font-style:italic">//一句话：把newtd指向oldfd的文件表项
</span><span style="color:#998;font-style:italic"></span>dup(<span style="color:#099">5</span>, <span style="color:#099">0</span>);
<span style="color:#998;font-style:italic">//标准输入重定向到描述符5指向的文件表
</span><span style="color:#998;font-style:italic">//会继承5打开文件的文件偏移量。因为指向的是同一个文件表。
</span></code></pre></div><h2 id="疑问">疑问</h2>
<p>明确几点：</p>
<ol>
<li>带缓冲函数，就是新建立一个结构，储存了fd(文件描述符)，还有缓冲的字节数组，等等东西，代替fd来使用。</li>
<li>文件偏移量，也就是移动位置是放在文件表结构上的，这里有一个问题，似乎不能多个进程同时打开一个文件。</li>
<li>文件元数据(metadata)，文件大小，文件类型放在v-node表上。
<ul>
<li>文件类型，文件中有一个type结构指定，例如文本文件，二进制文件，sockets文件。</li>
</ul>
</li>
<li>标准库IO是设计为读取文本文件的，所以其他类型文件不合适。</li>
</ol>

    </div>
</article>

        </main>
    </div><footer class="flex justify-center">
    <div class="copyright mx-auto my-8">
        <p>
            © 2018-2020 Bowser - <strong><a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong> - <strong>Power By Hugo | Theme By hugo-w2ng</strong>
        </p>
        
    </div>
</footer>





<script type="text/javascript" src="/js/instant.page.218f375afe49ca7960b6fc5ffe921ddae1fb2332f46ee5c292587dc370164cc857f533677b4fb60dc2341ca95096a5f3ed3d1615d5411144a034f9260082cdad.js" integrity="sha512-IY83Wv5Jynlgtvxf/pId2uH7IzL0buXCklh9w3AWTMhX9TNne0&#43;2DcI0HKlQlqXz7T0WFdVBEUSgNPkmAILNrQ=="></script>
</body>

</html>